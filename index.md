# Git

- Objects
  - **Blobs** are storage units for files, stored in directories called **trees**.
  - **Hashes** are hexadecimal strings that uniquely identify a blob, commit, or tree.
  - **Commits** are snapshots of code, stored as pointers to specific trees.
  - **Commit history** is a linked list/tree of commits, since each points to their predecessor.
  - **Branches** are pointers to specific commits that can be moved.
    - **HEAD** is a special pointer to the current branch.
- Places
  - **Working tree/directory** is the current state of the files visible to the user in the filesystem.
  - **Index** is a staging area/buffer for changes before the actual commit.
  - **Local repository** contains changes that have been committed from the staging area, as well as other branches, their entire commit history, etc.
  - **Remote repository** is separate from local, often on Github or another version control system.
  - **Stash** is a temporary holding area for changes only on the local repo.
- Common actions
  - **Cloning** (`git clone`) copies from the remote repo to local repo and working directory
    - This also sets HEAD to the currently active branch from the remote.
  - **Changes** to working directory affect **tracked files** that were in a previous commit or in the staging area, as well as **untracked files** which git has never seen before.
  - **Staging** (`git add`) adds changes made in the working directory to the index i.e. **staged files**.
  - **Viewing status** (`git status`) shows tracked, untracked, and staged files.
  - **Viewing differences** (`git diff`) shows changes between working tree and index.
    - `git diff HEAD` compares changes between working tree and last commit.
    - `git diff --staged` compares changes between index and last commit.
  - **Committing** (`git commit`) saves changes from the index to the local repo.
    - `-m` specifies the commit message inline rather than opening an editor.
    - `-a` stages all modified files, but only tracked files.
  - **Viewing commit history** (`git log`) lists all the commits of the working tree.
  - **Pushing** (`git push`) shares changes in the local repo to the remote repo.
  - **Fetching** (`git fetch`) shares changes in the remote repo to the local repo.
  - **Merging** (`git merge`) incorporates changes from one branch/commit history into another.
    - The merger’s changes are logged as a new commit on the destination branch.
  - **Pulling** (`git pull`) both fetches to local repo and merges with the local directory.
  - **Switching branches** (`git checkout <branch>`) swaps out working tree for <branch>.
    - `-b` creates a new branch in the local repo.
    - `-f` discards changes in working tree and index; normally these block checkout.
- Less-common actions
  - **Updating submodules** (`git submodule update --init`)
  - **Amending** (`git commit --amend`) modifies the previous commit; don’t do this after pushing.
  - **Restoring files** (`git checkout [<hash> --] <files>`)  overwrites <files> in the working tree and index for the versions from the commit with <hash>.
  - **Undo last commit** (`git reset --soft HEAD~1`) sets HEAD branch back by 1 commit, without touching any of the actual changes.
  - **Squashing** combines many commits into one, and can be done multiple ways.
    - To squash contiguous commits, use `git reset --soft HEAD~X` to move HEAD, but not working tree or index back by X commits, then use `git commit` as usual.
    - To squash non-contiguous commits, rewrite the last X commits of history with the interactive rebase tool `git rebase -i HEAD~X`. In the editor, reorder lines as needed and enter squash or `fixup` next to the commits that should be melded upwards.
  - **Cherry-picking** (`git cherry-pick`) applies the changes from existing commits.
    - `--no-commit` only stages, rather than committing (the default).
    - It's best to cherry pick one at a time, otherwise merge conflicts get confusing.
  - **Reverting** (`git revert`) undoes the changes from the specified commit(s).
    - `--no-commit` only stages, rather than committing (the default).
    - It's best to revert one at a time, otherwise merge conflicts get confusing.
- **Stash** is a temporary holding area for changes, stored as a stack (LIFO) data structure.
  - `git stash` moves tracked changes from the index and working tree to the stash
    - `-u` or `--include-untracked` also moves untracked files, which are normally ignored.
    - `git stash save <message>` includes a helpful message
  - `git stash pop` moves top of stash back to the working tree and index.
  - `git stash apply` copies top of stash back to working tree and index, leaving it in-place.
  - `git stash list` lists the stash entries in the stack.
- Aliases and other configuration
  - `git config --global alias.co checkout` so `git co` does `git checkout`.
  - `git config --global alias.br branch` so `git br` does `git branch`.
  - `git config --global alias.ci commit` so `git ci` does `git commit`.
  - `git config --global alias.st status` so `git st` does `git status`.
  - `git config --global alias.hist 'log --pretty=format:"%h - %an, %ar : %s"'` so `git hist` prints a condensed version of git log with one row per commit.
  - `git config --global core.fileMode false` ignores changes in file permissions.
  - [Autocompletion](https://git-scm.com/book/en/v1/Git-Basics-Tips-and-Tricks) with bash
  - `git lfs install` is needed before `git lfs pull`.
  - [Aliases can be unset](https://stackoverflow.com/questions/23512402/how-can-i-delete-a-git-alias) with `git config --global --unset`
- Resources
  - [Official Git reference documentation](https://git-scm.com/docs)
  - [(Official?) Pro Git book online](https://git-scm.com/book/en/v2)
  - [How to explain git in simple words?](https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words)
  - [How to teach Git](https://rachelcarmena.github.io/2018/12/12/how-to-teach-git.html)
  - [How to verify commits on github via GPG key](https://daily-dev-tips.com/posts/how-to-verify-your-commits-on-github/) + [use Apple Keychain to store GPG Passphrases](https://gist.github.com/koshatul/2427643668d4e89c0086f297f9ed2130)

# `zsh` shell
- zsh is an alternative shell to bash. It is the default in newer Macs [for licensing reasons](https://scriptingosx.com/2019/06/moving-to-zsh/).
- Oh My Zsh (OMZ) is a plugin framework for zsh with [a few builtins](https://github.com/ohmyzsh/ohmyzsh/wiki/Cheatsheet):
  - `omz --help` to get available commands
  - `omz update` to update oh my zsh
  - `omz reload` to apply changes made in .zshrc. Do not run source ~/.zshrc.
  - `..` = `cd ..` goes to parent directory
  - `...` = `cd ../..` goes to grandparent directory, also works for great-great-grandparent.
  - `d` = `dirs -v`, lists last visited directories
  - `-` = `cd` to last visited directory
  - `{1..9}` = cd to nth last visited directory in dir stack
- All plugins: `plugins=(git colored-man-pages zsh-autosuggestions zsh-syntax-highlighting docker)`
- [OMZ git plugin](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git) most commonly used aliases:
  - `gsb` = `git status -sb`
  - `gco` = `git checkout`
  - `gcb` = `git checkout -b`
  - `gcm` = `git checkout $(git_main_branch)`
  - `ga` = `git add`
  - `gcmsg` = `git commit -m`
  - `gcam` = `git commit -a -m`
  - `gl` = `git pull`
  - `gp` = `git push`
  - `gpsup` = `git push --set-upstream origin $(git_current_branch)`
  - `glol` = `git log` with pretty one-line view
  - `glols` = `git log` with pretty view showing changes
  - `gsu` = `git submodule update`
- powerlevel10k theme
  - Use [Iosevka patched with Nerd Fonts](https://github.com/ryanoasis/nerd-fonts/tree/master/patched-fonts/Iosevka) so that extra symbols are available.
- [zsh-syntax-highlighting external plugin](https://github.com/zsh-users/zsh-syntax-highlighting).
- [zsh-autosuggestions external plugin](https://github.com/zsh-users/zsh-autosuggestions)
- Resources
  - ["Moving to zsh" multi-part article](https://scriptingosx.com/2019/06/moving-to-zsh/)
  - [Configuring VSCode to work with zsh](https://linuxpip.org/vscode-zsh/)

# Docker

- Docker wraps code, runtime, system tools, and libraries into a complete filesystem that can be mounted and run on any environment that supports the Docker Engine.
  - **Containers** are instantiated by the Docker Engine on the host machine.
  - **Images** are the executable packages run by Docker Engine on the host machine.
  - **Layers** are the subcomponents of images. Since they are independent, changes to one layer does not require rebuilding other layers.
- **Dockerfiles** specify [commands](https://docs.docker.com/engine/reference/builder/) to be executed to assemble an image, including:
  - `FROM` sets the base image from which all other commands are run. This must be first.
  - `RUN` specifies a command to be run on the image, e.g. adding dependencies
  - `COPY` copies files from the local file system to the image.
  - `ADD` is similar to `COPY`, except with support for URLs and untarring.
  - `EXPOSE` defines the ports exposed at runtime, with mapping defined at runtime.
- Docker CLI commands
  - `docker build` builds an image from a Dockerfile.
  - `docker image ls` lists Docker images currently stored on the current host machine.
  - `docker container ls` lists Docker containers currently running on the host machine.
  - `docker ps` lists Docker containers currently running on the host machine.
  - `docker image ls` lists Docker images currently stored on the host machine. Note that the SIZE column double counts disk space used by layers in multiple images.
  - `docker container ls` lists Docker containers currently running on the host machine.
  - `docker run` TODO
  - `docker exec <image-id> -- <command>` performs the specified command on a running container, e.g. launch an interactive shell.
- Docker cleanup instructions
  - `docker system df -v` lists disk usage by images, containers, and volumes ([docs](https://docs.docker.com/engine/reference/commandline/system_df/)).
  - `docker system prune --volumes` will remove stopped containers, unused networks, dangling images, build cache, and volumes ([docs](https://docs.docker.com/config/pruning/)).
  - `docker image rm -f <image-ids>` to remove obsolete and large images.

# `apt` package manager for Linux/Ubuntu
- `dpkg` is the packaging system for Debian Linux, from which Ubuntu is derived.
- APT (Advanced Package Tool) is a friendlier command-line wrapper around dpkg.
  - `sudo apt update` will update the local database of available packages.
  - `sudo apt upgrade` will upgrade all packages that have available updates.
  - `sudo apt install` will install a new package or upgrade the existing one, if already installed.
  - `sudo apt remove` will uninstall a package, except for residue configuration files.
  - `sudo apt purge` will uninstall a package, including residue configuration files.
  - `apt search` will find all packages containing a search term.
  - `apt show` will display information about a package before installing or removing.
  - `apt list [--installed|--upgradeable]` will list installed packages (that can be upgraded).
  - `sudo apt autoremove` will remove packages installed automatically to satisfy the dependencies of other packages that have since been removed.
  - `sudo apt-key adv --keyserver <server> --recv-keys <key>` fixes the error "The following signatures couldn't be verified because the public key is not available" ([docs](https://chrisjean.com/fix-apt-get-update-the-following-signatures-couldnt-be-verified-because-the-public-key-is-not-available/)).
- Resources
  - [It’s FOSS - apt command guide](https://itsfoss.com/apt-command-guide/)
  - [Ubuntu Help - Managing Repositories](https://help.ubuntu.com/community/Repositories/CommandLine)

# Homebrew (brew) package manager for MacOS
- Homebrew is the "missing package manager for MacOS" similar to `apt` or `dpkg` from Linux.
  - **Tap** is a remote git repository of package(s). The default is `homebrew/core`.
  - **Formula** is a package definition stored in the Tap.
  - **Keg** is the installation directory of a single version of a Formula.
  - **Rack** is the directory containing one or more versions of a Formula.
  - **Cellar** is the local directory containing one or more Racks.
  - **Cask** is a Formula that installs native MacOS applications.
  - **Bottle** is a pre-built keg, used instead of building from source.
- Updating Homebrew and taps
  - **`brew update`** will update brew itself as well as all formulae.
  - **`brew tap`** lists current taps.
    - `brew tap user/repo` adds a new tab from Github user `user` and their repo `repo`.
    - `brew tap user/repo url` clones from a tap hosted somewhere other than Github.
- Interacting with formulae
  - **`brew list`** will list all installed formulae.
  - **`brew search name`** will search for packages matching `name`.
  - **`brew install <package>`** will install `package`.
  - **`brew uninstall <package>`** will uninstall `package`.
- Upgrading formulae
  - `brew outdated` lists all outdated formulae
  - **`brew upgrade [--dry-run]`** will update all taps and then upgrade their formulae.
    - **`brew upgrade <package>`** will only upgrade `package`.
  - `brew autoremove [--dry-run]` will remove formulae that were only installed as a dependency that is no longer needed.
  - `brew cleanup` will remove old versions, lock files, outdated files, etc.

# Python environments: pip, virtualenv, pipenv, conda
- Virtual Environments
  - **System packages** are built-in to the standard Python library.
  - **Site packages** are third party libraries that are installed separately in a folder specified by `import site; site.getsitepackages()`. But this doesn’t disambiguate versions.
  - **Virtual Environments** are isolated environments that allows each project to have its own dependencies, or different versions of the same dependencies.
  - **`pip install -r requirements.txt`** installs all dependencies in `requirements.txt`. Certain versions of dependencies can be pinned, e.g. `flask==0.12.1`. But this can still cause [dependency hell](https://en.wikipedia.org/wiki/Dependency_hell).
- Virtual Environments with **`pipenv`**
  - `pipenv` allows for deterministic builds without being responsible for updating versions of sub-dependencies in the `requirements.txt` file. It wraps both `pip` and `virtualenv`.
  - The current directory is the key for the environment; changing its name will break the link.
  - `pipenv install <package>[==<version]` installs a package for the current virtual environment, with an optional specified version, which is saved in the **`Pipfile`**.
    - `[dev-packages]` lists packages only needed for development. , installed with `pipenv --dev install`.
  - `Pipfile.lock` stores a snapshot of dependencies set (as hashes) by pipenv lock.
    - In prod, `pipenv install --ignore-pipfile` installs from `Pipfile.lock` instead of `Pipfile`, similar to `pip freeze`.
- Virtual Environments with **`Conda`**
  - **Conda** is a more broad package, environment, and dependency management system than pip since it is designed to work for all languages, not just Python.
  - **Anaconda** is a distribution of lots of software used in data science via Conda.
  - **Miniconda** is a distribution with minimal software to “start from scratch”.
  - **`conda env list`** lists all environments currently available.
  - **`conda create --name my_env`** creates a new environment my_env. Use the `python=3.x` flag to specify the version of Python to use.
  - **`conda activate my_env`** activates the environment my_env. deactivate returns to base.
  - **`conda env remove -n my_env`** deletes the specified environment.
  - **`conda list`** lists all packages installed in the current environment.
  - **`conda search`** searches current channels for a given package, accepting wildcards.
  - **`conda install`** solves dependencies and installs a package after prompting.
    - `--dry-run` flag will always stop before performing installation.
    - `-c <channel>` will search for the package in alternate channel `channel`.
  - **`conda update`** will update the specified package, or use --all flag to update everything.
  - **`pip install`** commands install to the current Conda environment!
  - **`conda env export`** generates a YML-formatted file with the environment for sharing.
  - **`conda clean`** TODO
  - **`conda remove --name my_env --all`** removes an environment and all installed packages.
- pip-tools
  - pip-compile TODO
- Resources
  - [Real Python: Python Virtual Environments - A Primer](https://realpython.com/python-virtual-environments-a-primer/)
  - [Real Python: Pipenv - A Guide to the New Python Packaging Tool](https://realpython.com/pipenv-guide/)
  - [Conda: Myths and Misconceptions](https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/)
  - [Real Python: Setting Up Python for Machine Learning on Windows](https://realpython.com/python-windows-machine-learning-setup/)